""" Module with functionalities for comparison of attribute values as well as
    record pairs. The record pair comparison function will return a dictionary
    of the compared pairs to be used for classification.
"""
import numpy as np


def compare_blocks(blockA_dict, blockB_dict, recA_dict, recB_dict,
                   attr_comp_list):
    """Build a similarity dictionary with pair of records from the two given
     block dictionaries. Candidate pairs are generated by pairing each record
     in a given block from data_io set A with all the records in the same block
     from dataset B.

     For each candidate pair a similarity vector is computed by comparing
     attribute values with the specified comparison method.

     Parameter Description:
       blockA_dict    : Dictionary of blocks from dataset A
       blockB_dict    : Dictionary of blocks from dataset B
       recA_dict      : Dictionary of records from dataset A
       recB_dict      : Dictionary of records from dataset B
       attr_comp_list : List of comparison methods for comparing individual
                        attribute values. This needs to be a list of tuples
                        where each tuple contains: (comparison function,
                        attribute number in record A, attribute number in
                        record B).

     This method returns a similarity vector with one similarity value per
     compared record pair.

     Example: sim_vec_dict = {(recA1,recB1) = [1.0,0.0,0.5, ...],
                              (recA1,recB5) = [0.9,0.4,1.0, ...],
                               ...
                             }
  """

    print('Compare %d blocks from dataset A with %d blocks from dataset B' % \
          (len(blockA_dict), len(blockB_dict)))

    sim_vec_dict = {}  # A dictionary where keys are record pairs and values
    # lists of similarity values

    # Iterate through each block in block dictionary from dataset A
    #
    for (block_bkv, rec_idA_list) in blockA_dict.items():

        # Check if the same blocking key occurs also for dataset B
        #
        if (block_bkv in blockB_dict):

            # If so get the record identifier list from dataset B
            #
            rec_idB_list = blockB_dict[block_bkv]

            # Compare each record in rec_id_listA with each record from rec_id_listB
            #
            for rec_idA in rec_idA_list:

                recA = recA_dict[rec_idA]  # Get the actual record A

                for rec_idB in rec_idB_list:
                    recB = recB_dict[rec_idB]  # Get the actual record B

                    # generate the similarity vector
                    #
                    if rec_idB != rec_idA:
                        sim_vec = compare_record(recA, recB, attr_comp_list)

                        # Add the similarity vector of the compared pair to the similarity
                        # vector dictionary
                        #
                        sim_vec_dict[(rec_idA, rec_idB)] = sim_vec

    print('  Compared %d record pairs' % (len(sim_vec_dict)))
    print('')

    return sim_vec_dict


def compare_pairs(pairs, recA_dict, recB_dict,
                  attr_comp_list):
    """Build a similarity dictionary with pair of records from the two given
     block dictionaries. Candidate pairs are generated by pairing each record
     in a given block from data_io set A with all the records in the same block
     from dataset B.

     For each candidate pair a similarity vector is computed by comparing
     attribute values with the specified comparison method.

     Parameter Description:
       blockA_dict    : Dictionary of blocks from dataset A
       blockB_dict    : Dictionary of blocks from dataset B
       recA_dict      : Dictionary of records from dataset A
       recB_dict      : Dictionary of records from dataset B
       attr_comp_list : List of comparison methods for comparing individual
                        attribute values. This needs to be a list of tuples
                        where each tuple contains: (comparison function,
                        attribute number in record A, attribute number in
                        record B).

     This method returns a similarity vector with one similarity value per
     compared record pair.

     Example: sim_vec_dict = {(recA1,recB1) = [1.0,0.0,0.5, ...],
                              (recA1,recB5) = [0.9,0.4,1.0, ...],
                               ...
                             }
  """

    sim_vec_dict = {}
    for a, b in pairs:
        if a.strip() in recA_dict and b.strip() in recB_dict:
            sim_vec = compare_record(recA_dict[a.strip()], recB_dict[b.strip()], attr_comp_list)
            sim_vec_dict[tuple(sorted([a.strip(), b.strip()]))] = sim_vec
        elif a.strip() in recB_dict and b.strip() in recA_dict:
            sim_vec = compare_record(recA_dict[b.strip()], recB_dict[a.strip()], attr_comp_list)
            sim_vec_dict[tuple(sorted([a.strip(), b.strip()]))] = sim_vec
    return sim_vec_dict


# -----------------------------------------------------------------------------

def compare_record(recA, recB, attr_comp_list):
    """Generate the similarity vector for the given record pair by comparing
     attribute values according to the comparison function and attribute
     numbers in the given attribute comparison list.

     Parameter Description:
       recA           : List of first record values for comparison
       recB           : List of second record values for comparison
       attr_comp_list : List of comparison methods for comparing attributes,
                        this needs to be a list of tuples where each tuple
                        contains: (comparison function, attribute number in
                        record A, attribute number in record B).

     This method returns a similarity vector with one value for each compared
     attribute.
  """

    sim_vec = []

    # Calculate a similarity for each attribute to be compared
    #
    for (comp_funct, attr_numA, attr_numB) in attr_comp_list:
        if 'jaccard' in comp_funct.__name__ or 'dice' in comp_funct.__name__:
            if attr_numA >= len(recA[1]):
                val_a = set()
            else:
                val_a = recA[1][attr_numA]
            if attr_numB >= len(recB[1]):
                val_b = set()
            else:
                val_b = recB[1][attr_numB]
        elif 'tfidf' in comp_funct.__name__:
            if attr_numA >= len(recA[1]):
                val_a = dict()
            else:
                val_a = recA[1][attr_numA]
            if attr_numB >= len(recB[1]):
                val_b = dict()
            else:
                val_b = recB[1][attr_numB]
        elif 'cosine' in comp_funct.__name__:
            if attr_numA >= len(recA[1]):
                val_a = np.zeros(300)
            else:
                val_a = recA[1][attr_numA]
            if attr_numB >= len(recB[1]):
                val_b = np.zeros(300)
            else:
                val_b = recB[1][attr_numB]
        else:
            if attr_numA >= len(recA[0]):  # Check there is a value for this attribute
                val_a = ''
            else:
                val_a = recA[0][attr_numA]

            if attr_numB >= len(recB[0]):
                val_b = ''
            else:
                val_b = recB[0][attr_numB]
        sim = comp_funct(val_a, val_b)
        sim_vec.append(sim)
    return sim_vec

# -----------------------------------------------------------------------------


# End of program.
